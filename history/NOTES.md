# ../History Development Notes

Generated from git commit history on 2025-08-02

## Development Timeline

### Commit 1: Doodles, history (#33) (db5f279)

This commit marks a significant leap in our ability to create engaging, dynamic development documentation, particularly for visual storytelling around complex topics like LLM evolution. The core problem we set out to solve was how to illustrate abstract concepts such as "hockey-stick growth," "LLM saturation," and "model collapse" in a way that was not only informative but also visually captivating and interactive, moving beyond static charts.

Our technical approach involved a multi-faceted pipeline. We chose Python, specifically Matplotlib and NumPy, for the backend generation of high-quality, programmatic SVG graphs. This allowed for precise control over data representation and graphical elements. The crucial architectural decision here was to output these visualizations as SVGs rather than raster images, enabling vector-based scalability and, critically, granular animation capabilities. On the frontend, the Slidev framework was adopted for presentation, largely due to its Vue.js component support and markdown-driven content structure. For the actual animation, the GreenSock Animation Platform (GSAP) was integrated, leveraging its powerful `stroke-dashoffset` technique to create compelling "drawing" effects for the graph lines.

A significant challenge overcome in this commit was orchestrating these SVG animations to trigger dynamically within the Slidev presentation. Rather than animating all SVGs on initial page load (which would be inefficient and distracting), we implemented a reusable `AnimatableSvg.vue` component. This component intelligently uses a `MutationObserver` to detect when its containing slide becomes visible (often via Slidev's `v-clicks` mechanism). Only then does it fetch the relevant SVG content, inject it into the DOM, and initiate the GSAP animations. This on-demand loading and animation ensures a smooth, performant user experience. Further implementation details include a Python utility function for dynamic label positioning within the SVGs to prevent overlaps, and the introduction of a slight `noise_factor` to the generated data to visually differentiate overlapping performance metrics on the graphs, enhancing clarity. This robust setup now allows us to easily create and embed complex, interactive data visualizations directly into our presentations.

### Commit 2: Also build history (#35) (db472ca)

## NOTES.md: db472ca - Also build history

This substantial commit marks the introduction of a dynamic, visually engaging 'History of LLMs' section into the project. The core problem being solved was how to convey the complex, evolving timeline and key milestones of Large Language Models in a digestible, interactive manner that static images or text alone couldn't achieve. The strategic decision was made to leverage **animatable SVGs** embedded within a new, dedicated 'slides' framework, providing a far richer and more compelling narrative experience. This moves beyond simple static presentations to truly *visualize* the progression of a complex topic.

Architecturally, this introduces a distinct `history/slides` directory structure, signifying a clear separation of concerns for this new content module. The choice of SVG for graphical elements is paramount; its vector nature ensures scalability and crispness across various display resolutions, while its XML structure allows for programmatic manipulation and animation via CSS and JavaScript. The sub-commits reveal the specific content: "History of LLMs: animatable graphs with labels" and a "Timeline," structured across "three scenarios" likely representing different perspectives or levels of detail. The commit title "Also build history" underscores the critical integration of this new content into the project's build pipeline, ensuring these dynamic assets are properly processed and deployed alongside the main application.

Naturally, integrating dynamic SVG content presented several technical challenges and required careful iteration. The notes "First pass at animatable SVGs" and "Despeckle to 5" indicate an iterative refinement process, focusing on getting the core animation logic functional and then optimizing the visual quality and performance of these intricate graphics. Further implementation details include "Fix clicks, captions" and "Change CSS," which point to ongoing UI/UX refinements to ensure the interactive elements and styling integrate seamlessly with the existing design system. The inclusion of the `linkedin.png` asset suggests the slides might also incorporate social sharing features or specific branding elements, reinforcing the intent for this content to be widely shareable and presentable. This commit essentially lays the groundwork for powerful, interactive data visualization, transforming what could be a static document into an engaging, animated story.

### Commit 3: Add license (#36) (21a92b1)

```markdown
## NOTES.md

### Commit: 21a92b1 - Add license

This commit, titled "Add license (#36)", marks a pivotal point in the project's lifecycle, serving a dual purpose. Primarily, it addresses the foundational requirement of clearly defining the project's intellectual property rights by integrating the Apache License 2.0 across the codebase. Beyond this crucial legal and open-source compliance step, the commit also represents the culmination of a significant development sprint focused on building sophisticated, animatable data visualizations, particularly for the "History of LLMs" section. The squashed commit message reveals a substantial body of work around dynamic graphs and interactive elements.

The technical approach to licensing was straightforward and robust: the full Apache License 2.0 boilerplate was systematically added as a header to all relevant source files. This includes Python scripts (`history/graph.py`), core HTML files (`history/index.html`, `history/slides/index.html`), and frontend Vue.js components (`AnimatableSvg.vue`, `Counter.vue`), as well as utility TypeScript files (`external.ts`). This comprehensive application ensures consistent licensing coverage across the diverse tech stack. A minor detail to note is the placeholder "2024 -l" in the copyright statement, which suggests a temporary or generic placeholder for the copyright holder that might need to be formalized later.

From a feature development perspective, this commit bundles the results of extensive work on interactive data presentation. The core architectural decision here revolves around creating "animatable SVGs" for historical timelines and graphs. This was achieved by leveraging Python (likely Matplotlib or similar) for generating SVG graph structures, integrating these into a Vue.js frontend via dedicated components (`AnimatableSvg.vue`), and employing the GSAP (GreenSock Animation Platform) library for rich, declarative animations. Overcoming challenges like fixing "clicks, captions", "despeckling" (likely refining SVG output), and ensuring smooth transitions for labels on these dynamic graphs required careful coordination between the SVG structure, CSS styling, and JavaScript animation logic within the Vue component lifecycle. This significant effort has laid the groundwork for highly engaging, data-driven storytelling within the project's documentation or presentation modules.
```

### Commit 4: Relative paths for SVGs (#37) (5b02279)

## NOTES.md Entry: `5b02279 - Relative paths for SVGs (#37)`

This commit represents a pivotal step in enhancing our presentation capabilities by introducing and stabilizing the use of dynamic, animatable SVG graphics within our slides. The overarching problem being solved was the limitation of static visual content; we needed a way to illustrate complex, evolving concepts – like the potential future trajectories of LLMs – with engaging, interactive visuals that could animate in sync with our presentation flow. The core technical approach involved the development and integration of a new `<AnimatableSvg>` component, designed to encapsulate the logic for loading and animating SVGs declaratively within our Markdown-based slide system. This component provides a clean interface, allowing slide authors to simply specify an SVG file and let the system handle the rendering and animation.

During the initial integration and development of these animatable SVGs, a subtle but crucial implementation challenge emerged: the SVG file paths were being referenced using absolute paths (e.g., `/hockey-stick.svg`). While this might seem innocuous, it's a brittle approach. Absolute paths hardcode the asset location relative to the web server's root, which can lead to broken references if the application is deployed to a sub-directory, or if local development server configurations differ from the production environment. To address this, a key architectural decision was made to shift to relative paths (e.g., `hockey-stick.svg`). This seemingly minor change drastically improves the portability and robustness of our asset references, allowing the underlying build system (presumably Sli.dev, Vite, or similar) to correctly resolve these assets irrespective of the deployment root.

The squashed nature of this commit indicates a comprehensive development effort that went beyond just the path fix. It encompassed the "first pass" at making these SVGs animatable, ensuring their interaction with slide click events (`v-click`), and refining their appearance. The introduction of specific visual metaphors like the "hockey-stick," "fixed-point," and "decay" scenarios using these animatable SVGs underscores the pedagogical value of this feature. This change not only resolves a critical pathing issue but also establishes a reliable pattern for embedding rich, dynamic content, setting a strong foundation for more interactive and visually compelling presentations going forward.

### Commit 5: Absolute URLs for SVGs (#38) (9ca5def)

### Commit: 9ca5def - Absolute URLs for SVGs

**Date:** September 24, 2024
**Author:** Peter Danenberg

This commit addresses a critical asset loading issue within our interactive presentation slides, specifically for the `<AnimatableSvg />` components used in the "History of LLMs" section. The core problem was that SVG assets, referenced via relative paths (e.g., `hockey-stick.svg`), were failing to load correctly in deployed environments, particularly when served from GitHub Pages at `https://google-gemini.github.io/workshops/`. While relative paths often work fine in local development, they frequently lead to incorrect resolution on static site hosting platforms where the base URL or directory structure for compiled content differs from the source, causing broken image links and a degraded user experience.

The technical approach taken was straightforward but highly effective: all SVG file paths within the `slides.md` files were updated from relative paths to explicit, absolute URLs. For instance, `svgFile="hockey-stick.svg"` was changed to `svgFile="https://google-gemini.github.io/workshops/history/hockey-stick.svg"`. This hardcoded, fully qualified URL ensures that the browser consistently fetches the SVG from its intended, publicly accessible location, irrespective of the current page's URL or the `AnimatableSvg` component's internal path resolution logic. This implicitly establishes a key architectural decision: our shared static assets, especially those integrated into dynamic components, will be referenced via absolute URLs pointing to a stable, public content delivery location.

This shift was likely a resolution to deployment-specific challenges that arose after an initial attempt to use relative paths (as indicated by the squashed commit message "Use relative paths for SVGs." preceding the final "Use absolute URLs for SVGs."). By moving to absolute URLs, we've overcome the ambiguity of relative pathing in a production deployment context, making our interactive slides more robust and ensuring that the crucial animated graphs (like the "hockey-stick" and "fixed-point" figures) always load as intended. This also provides greater clarity for future development, as developers now know precisely where these assets are expected to reside and how they should be referenced within the presentation framework.
